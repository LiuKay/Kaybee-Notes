import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,b as n}from"./app-C-ZhEtg7.js";const l="/assets/IO_blocking_model-CytA5vn5.png",s="/assets/IO_nonblocking_model-BQnn5zrR.png",a="/assets/IO_multiplexing_model-Bdi5nFFJ.png",c="/assets/IO_signal_driven_model-4YD1P6bG.png",r="/assets/IO_asynchronous_model-DcLmxD87.png",t="/assets/IO_models_comparison-BKU3_q5U.png",d={},p=n('<p>Unix 下的 5 种 I/O 模型</p><blockquote><p>《Unix 网络编程》中介绍了这 5 种 I/O 模型，由于该书中的示例图比较模糊，我照着画了一遍，原书中使用的是 UDP datagram 作为请求的数据，我这里统写为 data.</p></blockquote><h2 id="_1-阻塞-i-o-blocking-i-o" tabindex="-1"><a class="header-anchor" href="#_1-阻塞-i-o-blocking-i-o"><span>1. 阻塞 I/O - Blocking I/O</span></a></h2><p><img src="'+l+'" alt="IO_blocking_model" loading="lazy"></p><p>在阻塞的 I/O 模型中，发起读取调用时，应用程序阻塞在 <code>recvfrom</code>方法上，recvfrom 方法会进行系统调用读取内核空间中的数据，当数据未就绪时，则会等待数据就绪；当数据就绪时，数据会从内核空间拷贝到用户空间，当拷贝完成后，<code>recvfrom</code>方法返回，应用程序继续处理数据。在这整个过程中，recvfrom 方法和支持该方法的系统调用一直处于阻塞状态（无法返回），直到请求的数据到达内核，并从内核拷贝到了应用内存中。</p><h2 id="_2-非阻塞-i-o-nonblocking-i-o" tabindex="-1"><a class="header-anchor" href="#_2-非阻塞-i-o-nonblocking-i-o"><span>2. 非阻塞 I/O - Nonblocking I/O</span></a></h2><p><img src="'+s+'" alt="IO_nonblocking_model" loading="lazy"></p><p>在非阻塞 I/O 中，recvfrom 方法在数据未就绪时会立即返回一个错误，并不会阻塞地等待数据就绪。一般采用循环调用 recvfrom 的方式来检查数据是否就绪，一旦数据准备好，recvfrom 方法会等待数据从内核空间拷贝到应用内存后返回。</p><h2 id="_3-i-o-多路复用-i-o-multiplexing" tabindex="-1"><a class="header-anchor" href="#_3-i-o-多路复用-i-o-multiplexing"><span>3. I/O 多路复用 - I/O Multiplexing</span></a></h2><p><img src="'+a+'" alt="IO_multiplexing_model" loading="lazy"></p><p>在 I/O 多路复用的模型中，进程阻塞在 <code>select</code>或 <code>poll</code>方法上，不是真正的 I/O 系统调用(recvfrom),当数据可读时，再调用 recvfrom 方法将数据拷贝到应用内存中。与上文提到的阻塞 I/O 模型对比，I/O 多路复用需要使用2个系统调用来完成操作，但其优势在于，一个<code>select</code>方法可以监听在多个文件描述符上面，同时监听多个 I/O 是否可读。</p><h2 id="_4-信号驱动的-i-o-signal-driven-i-o" tabindex="-1"><a class="header-anchor" href="#_4-信号驱动的-i-o-signal-driven-i-o"><span>4. 信号驱动的 I/O - Signal Driven I/O</span></a></h2><p><img src="'+c+'" alt="IO_signal_driven_model" loading="lazy"></p><p>在信号驱动的模型中，我们先注册一个信号处理器到系统调用 <code>sigaction</code>上，这个调用是非阻塞的，并会立即返回，应用进程可以继续处理后面的逻辑，一旦数据就绪时将会产生信号，应用进程可以通过注册的处理器读取数据或通过调用 recvfrom 读取数据。整个过程在等待数据就绪时候是非阻塞的。</p><h2 id="_5-异步-i-o-asynchronous-i-o" tabindex="-1"><a class="header-anchor" href="#_5-异步-i-o-asynchronous-i-o"><span>5. 异步 I/O - Asynchronous I/O</span></a></h2><p><img src="'+r+'" alt="IO_asynchronous_model" loading="lazy"></p><p>异步 I/O 是由 POSIX 规范定义的，其工作过程是当调用异步 I/O 方法时就立即返回了，应用进程会继续去处理后面的逻辑，内核会负责整个 I/O 操作(包括等待数据就绪和将数据拷贝至应用内存中)，与信号驱动 I/O 模型的区别在于，内核在信号驱动的I/O 中会通知我们何时可以开始 I/O 操作(真正读数据，即拷贝数据)，而在异步 I/O 中内核是通知我们何时完成 I/O .</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p><img src="'+t+'" alt="IO_models_comparison" loading="lazy"></p><p>POSIX 定义了同步和异步 I/O 的定义：</p><ul><li>同步 I/O（synchronous I/O）：A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li><li>异步 I/O（asynchronous I/O）：An asynchronous I/O operation does not cause the requesting process to be blocked.</li></ul><p>按以上定以来说，上面前 4 种 I/O 模型(阻塞、非阻塞、I/O 多路复用、信号驱动 I/O)都属于同步 I/O，因为它们在真正的 I/O 操作过程中(recvfrom) 都会阻塞调用进程。只有最后一个模型符合 POSIX 定义的异步 I/O.</p>',22),I=[p];function O(_,m){return e(),i("div",null,I)}const u=o(d,[["render",O],["__file","IO-Models.html.vue"]]),v=JSON.parse('{"path":"/ARTS/IO-Models.html","title":"Linux I/O Models","lang":"zh-CN","frontmatter":{"title":"Linux I/O Models","date":"2021-12-28T00:00:00.000Z","category":["编程技术"],"tag":["Linux","基础内功","总结","REVIEW"]},"headers":[{"level":2,"title":"1. 阻塞 I/O - Blocking I/O","slug":"_1-阻塞-i-o-blocking-i-o","link":"#_1-阻塞-i-o-blocking-i-o","children":[]},{"level":2,"title":"2. 非阻塞 I/O - Nonblocking I/O","slug":"_2-非阻塞-i-o-nonblocking-i-o","link":"#_2-非阻塞-i-o-nonblocking-i-o","children":[]},{"level":2,"title":"3. I/O 多路复用 - I/O Multiplexing","slug":"_3-i-o-多路复用-i-o-multiplexing","link":"#_3-i-o-多路复用-i-o-multiplexing","children":[]},{"level":2,"title":"4. 信号驱动的 I/O - Signal Driven I/O","slug":"_4-信号驱动的-i-o-signal-driven-i-o","link":"#_4-信号驱动的-i-o-signal-driven-i-o","children":[]},{"level":2,"title":"5. 异步 I/O - Asynchronous I/O","slug":"_5-异步-i-o-asynchronous-i-o","link":"#_5-异步-i-o-asynchronous-i-o","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1663489876000,"updatedTime":1663489876000,"contributors":[{"name":"LiuKay","email":"kayfen@foxmail.com","commits":1}]},"readingTime":{"minutes":3,"words":899},"filePathRelative":"ARTS/IO-Models.md","localizedDate":"2021年12月28日","excerpt":"<p>Unix 下的 5 种 I/O 模型</p>\\n<blockquote>\\n<p>《Unix 网络编程》中介绍了这 5 种 I/O 模型，由于该书中的示例图比较模糊，我照着画了一遍，原书中使用的是 UDP datagram 作为请求的数据，我这里统写为 data.</p>\\n</blockquote>\\n<h2>1. 阻塞 I/O - Blocking I/O</h2>\\n<p></p>\\n<p>在阻塞的 I/O 模型中，发起读取调用时，应用程序阻塞在 <code>recvfrom</code>方法上，recvfrom 方法会进行系统调用读取内核空间中的数据，当数据未就绪时，则会等待数据就绪；当数据就绪时，数据会从内核空间拷贝到用户空间，当拷贝完成后，<code>recvfrom</code>方法返回，应用程序继续处理数据。在这整个过程中，recvfrom 方法和支持该方法的系统调用一直处于阻塞状态（无法返回），直到请求的数据到达内核，并从内核拷贝到了应用内存中。</p>"}');export{u as comp,v as data};
